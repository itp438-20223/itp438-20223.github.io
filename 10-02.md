---
title: Chat
parent: Assignment 10
grand_parent: Assignments
has_children: false
nav_order: 2
---

# Chat

In this part, you'll add support for text chat messages. Players will be able to send chat messages either to only their team ***or*** to everyone. Although it'll be a bit of work to get there, ultimately chat will work like this:

<video style="display:block; margin: 0 auto;" width="640" height="360" controls>
  <source src="assets/10-2.mp4" type="video/mp4">
</video>

As there's several steps to get this working, I'll explain the order I think it makes the most sense to implement in, so that you can effectively test it.

## UMG Changes and Message Visuals

As a first step, you want to add the additional widgets to the hierarchy of the `HUDWidget_BP` as outlined in the lecture notes. Some notes:

- For `ChatBox`, set the "Size X" to `600` and "Size Y" to `400`
- For `ChatScrollBox`, you'll want to set the size to "Fill" so that it will fill the rest of `ChatBox` as much as it possibly can
- For both `ChatTeam` and `ChatText` box, set the font size to `18`
- Remember you'll want to add a corresponding `BindWidget` properties in code for each of the different widgets you add 

Next, create a new C++ subclass of UserWidget called `ChatMessageWidget` and make a child of it called `ChatMessageWidget_BP`. Then setup the elements in it as outlined in the slides. Some notes:

- For the Size Box, set "Size To Content" to true and set the "Width Override" to 600
- Set the font size of all text elements to 18
- For the Message text box, set the size to "Fill" and enable "Auto Wrap Text"
- Remember you'll need `BindWidget` properties for `Channel`, `Sender`, and `Message`

Now, add a new public function to `HUDWidget` called `AddChatMessage`, which should have three parameters:

- An `EMultiTeam` for the team (if it's going to "all" chat, the team would be set to None)
- A `const FString&` for the sender's name
- A `const FString&` for the message

This function should correctly construct and add a chat message widget to the chat messages vertical box, and set the text as appropriate based on the parameters. For the Channel display:

- Show `[All]` in white if it's to all chat
- Show `[Team]` in either red or blue depending on which team the local player is on 

*Hints*:

- Remember since you'll need to construct a widget of type `ChatMessageWidget_BP`, you'll need a `TSubclassOf` property to be able to specify the chat message type you want to create
- To modify a `UPROPERTY` in a widget you may have to go to the Event Graph to be able to change the default value
- Remember you need to use `NewObject` to construct an instance of it
- You have to add the new message to the chat messages vertical box _before_ trying to change any of its text blocks (or you'll get a null pointer exception)
- Use `ScrollToEnd` to force the scroll box to always scroll to the end

To test this, in `MultiPlayerController`'s `BeginPlay`, you can try manually calling `AddChatMessage` multiple times and see what the result looks like on screen. You can verify the messages look correct, and also verify the scrolling works.

## Text Input

Once you confirm the display of the test messages work, go ahead and comment out the manual calls to `AddChatMessage`.

Now you should get the text input working. You want it so that while playing the game, if the player presses either `T` or Y, the focus is changed to the `ChatTextBox`. If the player presses `T`, the `ChatTeam` text block should say `[Team]` and otherwise it should say `[All]`.

For focus to work properly, remember that:

- "Is Focusable" must be set to `true` in `HUDWidget_BP`
- When you create the `HUDInstance`, you also need to set the owning player

Then, when the player presses either the `T` or `Y` key you want to change the input mode to `UIOnly`, and focus `ChatTextBox`.

Next, in C++ you want to setup the dynamic delegate binding to the `OnTextCommitted` delegate on `ChatTextBox`. You'll need to override `NativeConstruct` to add the delegate. Remember your delegate implementation needs to be a `UFUNCTION`.

For now, make it so when the player types a message and commits it, the `ChatTextBox` text is cleared and it sets the input mode back to the game.

To confirm this works properly, you'll want to try pressing `T` and `Y`, typing a message, and hitting enter. You should be able to continue playing the game when you hit enter (and the text will go away). Also confirm you show [Team] or [All] as appropriate.

## Networking the Text

Now you need to set it up so `MultiPlayerState` has both a server function for sending a message and a client function for receiving the message on clients. The signature of these function can be the same as `AddChatMessage`.

Then when the text is committed from `ChatTextBox`, if the commit was due to the enter key, call the server function. Use the correct team is it's for team chat or otherwise use none if it's for all chat.

Then the server function needs to decide which player states in the game should receive the message and send it to those player states individually. You may want to review the part of the lecture that covered it.

*Hint*: You can get the `PlayerArray` which contains all the player state pointers from the `GameState`.

Then the client function simply needs to call `AddChatMessage` to add the message to the display box.

If this works properly, you should now be able to send messages both to all chat and team chat. Confirm that both the red team and blue team messages work as expected (only going to the players on that team).

## Hiding ChatEntry

The last thing to do is making it so that, by default, the `ChatEntry` box is hidden by default in `HUDWidget_BP`. Then, when the player presses `T` or `Y`, change `ChatEntry`'s visibility to `SelfHitTestInvisible` _before_ you set it to be focused. Then when text is committed, hide the `ChatEntry` widget again.

Once this is done, your chat should work like the chat in the video at the top of this page! Then you're ready to move on to [part 3](10-03.html).
